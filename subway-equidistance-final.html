<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NYC Subway Equidistance Map</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src='https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js'></script>
    <link href='https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css' rel='stylesheet' />
    <script src='https://unpkg.com/@turf/turf@6.5.0/turf.min.js'></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
        }
        
        /* MapLibre Popup Styling */
        .maplibregl-popup-content {
            background: rgba(0, 0, 0, 0.95) !important;
            border: 1px solid #333 !important;
            border-radius: 6px !important;
            box-shadow: 0 4px 20px rgba(0,0,0,0.7) !important;
            padding: 12px !important;
        }
        .maplibregl-popup-tip {
            border-top-color: rgba(0, 0, 0, 0.95) !important;
        }
        
        #map {
            width: 100vw;
            height: 100vh;
        }
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
            max-width: 320px;
            z-index: 1;
            border: 1px solid #333;
        }
        .controls h2 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #ffffff;
        }
        .station-select {
            margin-bottom: 15px;
        }
        .station-select label {
            display: block;
            font-size: 12px;
            color: #aaaaaa;
            margin-bottom: 5px;
            font-weight: 600;
        }
        .station-badge {
            display: inline-block;
            padding: 8px 12px;
            background: #222;
            border-radius: 4px;
            font-size: 14px;
            color: #ccc;
        }
        .station-badge.selected {
            background: #007cbf;
            color: white;
        }
        .station-badge.station-a {
            background: #FFD700;
            color: #000;
            font-weight: bold;
        }
        .station-badge.station-b {
            background: #1E90FF;
            color: white;
            font-weight: bold;
        }
        .station-badge.prompt {
            background: #444;
            color: #FFD700;
            font-weight: bold;
        }
        .instructions {
            font-size: 13px;
            color: #aaaaaa;
            line-height: 1.5;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #333;
        }
        button {
            width: 100%;
            padding: 10px;
            background: #007cbf;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            margin-top: 10px;
        }
        button:hover {
            background: #006399;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .debug-window {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            color: #00ff00;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            font-family: 'Courier New', monospace;
            font-size: 11px;
            max-width: 400px;
            max-height: 300px;
            overflow-y: auto;
            z-index: 1;
        }
        .debug-window h3 {
            color: #00ff00;
            font-size: 12px;
            margin-bottom: 10px;
            border-bottom: 1px solid #00ff00;
            padding-bottom: 5px;
        }
        .debug-line {
            margin-bottom: 3px;
            line-height: 1.4;
        }
        .debug-error {
            color: #ff4444;
        }
        .debug-success {
            color: #44ff44;
        }
        .debug-info {
            color: #4444ff;
        }
        .legend {
            position: absolute;
            bottom: 40px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
            z-index: 1;
            border: 1px solid #333;
        }
        .legend h3 {
            font-size: 14px;
            margin-bottom: 10px;
            color: #ffffff;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 12px;
            color: #cccccc;
        }
        .legend-color {
            width: 30px;
            height: 15px;
            margin-right: 10px;
            border-radius: 2px;
        }
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 20px 30px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            border: 1px solid #333;
            z-index: 1000;
            font-size: 16px;
            color: #ffffff;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Will be loaded from travel_times.json
        let TRAVEL_DATA = null;
        let STATIONS = [];

        const SubwayEquidistanceMap = () => {
            const mapContainer = useRef(null);
            const map = useRef(null);
            const popup = useRef(null);
            const [mapLoaded, setMapLoaded] = useState(false);
            const [dataLoaded, setDataLoaded] = useState(false);
            const [stationA, setStationA] = useState(null);
            const [stationB, setStationB] = useState(null);
            const [isCalculating, setIsCalculating] = useState(false);
            const [selectionMode, setSelectionMode] = useState(true);
            const [debugLogs, setDebugLogs] = useState([]);
            
            // Debug logging function
            const addDebugLog = (message, type = 'info') => {
                const timestamp = new Date().toLocaleTimeString();
                setDebugLogs(prev => [...prev.slice(-20), { message, type, timestamp }]);
            };
            
            // Load travel times data
            useEffect(() => {
                addDebugLog('Loading travel times data...', 'info');
                fetch('travel_times.json')
                    .then(response => response.json())
                    .then(data => {
                        TRAVEL_DATA = data;
                        STATIONS = Object.values(data.stations);
                        addDebugLog(`Loaded ${STATIONS.length} stations`, 'success');
                        setDataLoaded(true);
                    })
                    .catch(error => {
                        console.error('Error loading travel times:', error);
                        alert('Error loading travel times data. Please make sure travel_times.json is in the same directory.');
                    });
            }, []);
            
            // Use refs to track current state in event handlers
            const stationARef = useRef(null);
            const stationBRef = useRef(null);
            const selectionModeRef = useRef(true);
            
            useEffect(() => {
                stationARef.current = stationA;
            }, [stationA]);
            
            useEffect(() => {
                stationBRef.current = stationB;
            }, [stationB]);
            
            useEffect(() => {
                selectionModeRef.current = selectionMode;
            }, [selectionMode]);

            useEffect(() => {
                if (map.current || !dataLoaded) return;

                map.current = new maplibregl.Map({
                    container: mapContainer.current,
                    style: {
                        version: 8,
                        sources: {
                            'carto-dark': {
                                type: 'raster',
                                tiles: [
                                    'https://a.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png',
                                    'https://b.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png',
                                    'https://c.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png'
                                ],
                                tileSize: 256,
                                attribution: '&copy; OpenStreetMap contributors &copy; CARTO'
                            }
                        },
                        layers: [{
                            id: 'carto-dark-layer',
                            type: 'raster',
                            source: 'carto-dark',
                            minzoom: 0,
                            maxzoom: 22
                        }]
                    },
                    center: [-73.97, 40.76],
                    zoom: 11
                });

                map.current.on('load', () => {
                    setMapLoaded(true);
                    
                    // Create a popup for showing travel times on hover
                    popup.current = new maplibregl.Popup({
                        closeButton: false,
                        closeOnClick: false,
                        offset: 15
                    });
                    
                    // Add station markers source
                    map.current.addSource('stations', {
                        type: 'geojson',
                        data: {
                            type: 'FeatureCollection',
                            features: STATIONS.map(station => ({
                                type: 'Feature',
                                properties: {
                                    id: station.id,
                                    name: station.name
                                },
                                geometry: {
                                    type: 'Point',
                                    coordinates: [station.lon, station.lat]
                                }
                            }))
                        }
                    });

                    // Add station circles
                    map.current.addLayer({
                        id: 'station-circles',
                        type: 'circle',
                        source: 'stations',
                        paint: {
                            'circle-radius': 8,
                            'circle-color': '#ffffff',
                            'circle-stroke-width': 2,
                            'circle-stroke-color': '#007cbf'
                        }
                    });

                    // Add station labels
                    map.current.addLayer({
                        id: 'station-labels',
                        type: 'symbol',
                        source: 'stations',
                        layout: {
                            'text-field': ['get', 'name'],
                            'text-size': 11,
                            'text-offset': [0, 1.5],
                            'text-anchor': 'top'
                        },
                        paint: {
                            'text-color': '#ffffff',
                            'text-halo-color': '#000000',
                            'text-halo-width': 1
                        }
                    });

                    // Station click handler
                    const handleStationClick = (e) => {
                        if (!selectionModeRef.current) {
                            addDebugLog('Click ignored - not in selection mode', 'error');
                            return;
                        }
                        
                        const stationId = e.features[0].properties.id;
                        const station = STATIONS.find(s => s.id === stationId);
                        
                        if (!stationARef.current) {
                            addDebugLog(`Selected Station A: ${station.name}`, 'success');
                            setStationA(station);
                        } else if (!stationBRef.current && station.id !== stationARef.current.id) {
                            addDebugLog(`Selected Station B: ${station.name}`, 'success');
                            setStationB(station);
                        } else {
                            addDebugLog('Station already selected or same as A', 'error');
                        }
                    };
                    
                    map.current.on('click', 'station-circles', handleStationClick);

                    // Hover handler to show travel times
                    map.current.on('mouseenter', 'station-circles', (e) => {
                        map.current.getCanvas().style.cursor = 'pointer';
                        
                        if (!stationARef.current || !stationBRef.current) return;
                        
                        const stationId = e.features[0].properties.id;
                        const station = STATIONS.find(s => s.id === stationId);
                        const coordinates = [station.lon, station.lat];
                        
                        const timesFromA = TRAVEL_DATA.travel_times[stationARef.current.id] || {};
                        const timesFromB = TRAVEL_DATA.travel_times[stationBRef.current.id] || {};
                        
                        const timeToA = timesFromA[stationId] !== undefined ? timesFromA[stationId] : 999;
                        const timeToB = timesFromB[stationId] !== undefined ? timesFromB[stationId] : 999;
                        
                        const timeADisplay = timeToA === 999 ? 'N/A' : timeToA.toFixed(1) + ' min';
                        const timeBDisplay = timeToB === 999 ? 'N/A' : timeToB.toFixed(1) + ' min';
                        
                        const html = `
                            <div style="font-family: Arial, sans-serif; font-size: 12px; min-width: 150px; color: #fff;">
                                <div style="font-weight: bold; margin-bottom: 5px; border-bottom: 1px solid #555; padding-bottom: 3px; color: #fff;">
                                    ${station.name}
                                </div>
                                <div style="color: #FFD700; font-weight: bold; margin: 3px 0;">
                                    â†“ ${stationARef.current.name}: ${timeADisplay}
                                </div>
                                <div style="color: #1E90FF; font-weight: bold; margin: 3px 0;">
                                    â†“ ${stationBRef.current.name}: ${timeBDisplay}
                                </div>
                                ${timeToA !== 999 && timeToB !== 999 ? `
                                    <div style="margin-top: 5px; padding-top: 3px; border-top: 1px solid #444; font-size: 11px; color: #aaa;">
                                        Difference: ${Math.abs(timeToA - timeToB).toFixed(1)} min
                                    </div>
                                ` : ''}
                            </div>
                        `;
                        
                        popup.current.setLngLat(coordinates).setHTML(html).addTo(map.current);
                    });

                    map.current.on('mouseleave', 'station-circles', () => {
                        map.current.getCanvas().style.cursor = '';
                        popup.current.remove();
                    });
                });
            }, [dataLoaded]);

            // Update map markers when stations are selected (but only for initial selection, not after calculation)
            useEffect(() => {
                if (!mapLoaded || !map.current || !selectionMode) return;

                const selectedIds = [stationA?.id, stationB?.id].filter(Boolean);

                if (selectedIds.length > 0) {
                    map.current.setPaintProperty('station-circles', 'circle-color', [
                        'case',
                        ['==', ['get', 'id'], stationA?.id || ''], '#FFD700',
                        ['==', ['get', 'id'], stationB?.id || ''], '#1E90FF',
                        '#ffffff'
                    ]);

                    map.current.setPaintProperty('station-circles', 'circle-radius', [
                        'case',
                        ['in', ['get', 'id'], ['literal', selectedIds]], 12,
                        8
                    ]);

                    map.current.setPaintProperty('station-circles', 'circle-stroke-width', 2);
                    map.current.setPaintProperty('station-circles', 'circle-stroke-color', '#007cbf');
                } else {
                    // Reset to defaults when no stations selected
                    map.current.setPaintProperty('station-circles', 'circle-color', '#ffffff');
                    map.current.setPaintProperty('station-circles', 'circle-radius', 8);
                    map.current.setPaintProperty('station-circles', 'circle-stroke-width', 2);
                    map.current.setPaintProperty('station-circles', 'circle-stroke-color', '#007cbf');
                    map.current.setPaintProperty('station-circles', 'circle-opacity', 1);
                }
            }, [stationA, stationB, mapLoaded, selectionMode]);

            const calculateEquidistance = async () => {
                if (!stationA || !stationB) return;

                addDebugLog('Starting equidistance calculation...', 'info');
                setIsCalculating(true);
                setSelectionMode(false);

                try {
                    // Get travel times from pre-computed data  (in minutes)
                    const timesFromA = TRAVEL_DATA.travel_times[stationA.id] || {};
                    const timesFromB = TRAVEL_DATA.travel_times[stationB.id] || {};
                    
                    // Remove existing layers
                    for (let i = 0; i < 4; i++) {
                        if (map.current.getLayer(`isochrone-a-${i}`)) {
                            map.current.removeLayer(`isochrone-a-${i}`);
                        }
                        if (map.current.getSource(`isochrone-a-${i}`)) {
                            map.current.removeSource(`isochrone-a-${i}`);
                        }
                        if (map.current.getLayer(`isochrone-b-${i}`)) {
                            map.current.removeLayer(`isochrone-b-${i}`);
                        }
                        if (map.current.getSource(`isochrone-b-${i}`)) {
                            map.current.removeSource(`isochrone-b-${i}`);
                        }
                    }

                    // Color stations based on relative distance
                    const stationColorData = STATIONS.map(station => {
                        const timeToA = timesFromA[station.id] !== undefined ? timesFromA[station.id] : 999;
                        const timeToB = timesFromB[station.id] !== undefined ? timesFromB[station.id] : 999;
                        
                        let color;
                        let isEquidistant = false;
                        let shouldShow = true;
                        const maxDisplayTime = 40; // Only show stations within 40 minutes
                        
                        if (station.id === stationA.id) {
                            color = '#FFD700'; // Gold/Yellow
                        } else if (station.id === stationB.id) {
                            color = '#1E90FF'; // Dodger Blue
                        } else if (timeToA === 999 && timeToB === 999) {
                            // Completely unreachable - hide
                            shouldShow = false;
                            color = '#666666';
                        } else if (timeToA > maxDisplayTime && timeToB > maxDisplayTime) {
                            // Too far from both - hide
                            shouldShow = false;
                            color = '#666666';
                        } else if (timeToA === 999) {
                            // Only reachable from B
                            if (timeToB <= maxDisplayTime) {
                                color = '#1E90FF';
                            } else {
                                shouldShow = false;
                                color = '#666666';
                            }
                        } else if (timeToB === 999) {
                            // Only reachable from A
                            if (timeToA <= maxDisplayTime) {
                                color = '#FFD700';
                            } else {
                                shouldShow = false;
                                color = '#666666';
                            }
                        } else {
                            const diff = timeToA - timeToB; // positive = closer to A (yellow), negative = closer to B (blue)
                            const maxDiff = 20; // minutes - used for gradient scaling
                            
                            if (Math.abs(diff) <= 5) {
                                color = '#00FF00'; // Pure green for equidistant (within 5 min)
                                isEquidistant = true;
                            } else if (diff > 5) {
                                // Closer to A (yellow) - gradient from yellow (#FFD700 = rgb(255,215,0)) to green (0,255,0)
                                const ratio = Math.min((diff - 5) / maxDiff, 1);
                                const r = 255;
                                const g = Math.floor(215 - 215 * (1 - ratio) * 0.3); // Subtle shift toward green
                                const b = 0;
                                color = `rgb(${r}, ${g}, ${b})`;
                            } else {
                                // Closer to B (blue) - gradient from blue (#1E90FF = rgb(30,144,255)) to green (0,255,0)
                                const ratio = Math.min((Math.abs(diff) - 5) / maxDiff, 1);
                                const r = Math.floor(30 * (1 - ratio * 0.3));
                                const g = Math.floor(144 + (255 - 144) * (1 - ratio) * 0.3); // Subtle shift toward green
                                const b = 255;
                                color = `rgb(${r}, ${g}, ${b})`;
                            }
                        }
                        
                        return { id: station.id, color, isEquidistant, shouldShow };
                    });

                    // Get IDs for different categories
                    const equidistantIds = stationColorData.filter(s => s.isEquidistant).map(s => s.id);
                    const hiddenIds = stationColorData.filter(s => !s.shouldShow).map(s => s.id);

                    // Debug: log how many equidistant stations we found
                    addDebugLog(`Found ${equidistantIds.length} equidistant stations`, 'success');
                    const equidistantStations = stationColorData.filter(s => s.isEquidistant);
                    equidistantStations.slice(0, 5).forEach(s => {
                        const station = STATIONS.find(st => st.id === s.id);
                        const timeToA = timesFromA[s.id];
                        const timeToB = timesFromB[s.id];
                        addDebugLog(`  ${station.name}: ${timeToA.toFixed(1)}min from A, ${timeToB.toFixed(1)}min from B`, 'info');
                    });
                    if (equidistantStations.length > 5) {
                        addDebugLog(`  ... and ${equidistantStations.length - 5} more`, 'info');
                    }

                    // Hide stations that are too far away
                    map.current.setPaintProperty('station-circles', 'circle-opacity', [
                        'case',
                        ['in', ['get', 'id'], ['literal', hiddenIds]], 0,
                        1
                    ]);
                    
                    // Set station colors
                    map.current.setPaintProperty('station-circles', 'circle-color', [
                        'match',
                        ['get', 'id'],
                        ...stationColorData.flatMap(s => [s.id, s.color]),
                        '#ffffff'
                    ]);
                    
                    // Set station stroke color - WHITE for equidistant stations only
                    map.current.setPaintProperty('station-circles', 'circle-stroke-color', [
                        'case',
                        ['in', ['get', 'id'], ['literal', equidistantIds]], '#ffffff',
                        'rgba(0,0,0,0)' // Transparent for non-equidistant
                    ]);
                    
                    // Set station stroke width - 4px for equidistant (very visible), 0 for others
                    map.current.setPaintProperty('station-circles', 'circle-stroke-width', [
                        'case',
                        ['in', ['get', 'id'], ['literal', equidistantIds]], 4,
                        0
                    ]);
                    
                    map.current.setPaintProperty('station-circles', 'circle-radius', [
                        'case',
                        ['==', ['get', 'id'], stationA.id], 12,
                        ['==', ['get', 'id'], stationB.id], 12,
                        6
                    ]);

                    // Following the NYC Subway Isochrones algorithm
                    // Walking speed: 1.2 m/s = 72 m/min = 0.072 km/min
                    const timeIntervals = [10, 20, 30, 40]; // minutes
                    // Yellow gradient for station A
                    const colorsA = ['rgba(255, 215, 0, 0.6)', 'rgba(255, 215, 0, 0.4)', 'rgba(255, 215, 0, 0.25)', 'rgba(255, 215, 0, 0.15)'];
                    // Blue gradient for station B
                    const colorsB = ['rgba(30, 144, 255, 0.6)', 'rgba(30, 144, 255, 0.4)', 'rgba(30, 144, 255, 0.25)', 'rgba(30, 144, 255, 0.15)'];
                    
                    const isochronesA = [];
                    const isochronesB = [];

                    // Process each time interval
                    for (let idx = 0; idx < timeIntervals.length; idx++) {
                        const maxTimeMinutes = timeIntervals[idx];
                        
                        // STATION A ISOCHRONE
                        try {
                            let buffersA = [];
                            
                            // Get all stations reachable within this time interval
                            const reachableA = Object.entries(timesFromA)
                                .filter(([_, time]) => time > 0 && time <= maxTimeMinutes)
                                .map(([stationId, duration]) => {
                                    const station = STATIONS.find(s => s.id === stationId);
                                    if (!station) return null;
                                    
                                    // Calculate leftover walking time
                                    const leftoverMinutes = maxTimeMinutes - duration;
                                    const bufferKm = leftoverMinutes * 0.072; // 1.2 m/s = 0.072 km/min
                                    
                                    return turf.buffer(
                                        turf.point([station.lon, station.lat]),
                                        bufferKm > 0 ? bufferKm : 0.01,
                                        { units: 'kilometers' }
                                    );
                                })
                                .filter(b => b !== null);
                            
                            buffersA = [...reachableA];
                            
                            // Buffer the previous isochrone by a full 10-minute walk
                            if (idx > 0 && isochronesA[idx - 1]) {
                                const prevBuffer = turf.buffer(
                                    isochronesA[idx - 1],
                                    0.720, // 10 minutes * 0.072 km/min
                                    { units: 'kilometers' }
                                );
                                buffersA.push(...prevBuffer.features);
                            }
                            
                            if (buffersA.length > 0) {
                                // Create feature collection and dissolve
                                const fc = turf.featureCollection(buffersA);
                                const dissolved = turf.dissolve(fc);
                                
                                isochronesA[idx] = dissolved;
                                
                                // Add to map (reverse order so largest is on bottom)
                                const displayIdx = timeIntervals.length - 1 - idx;
                                map.current.addSource(`isochrone-a-${displayIdx}`, {
                                    type: 'geojson',
                                    data: dissolved
                                });

                                map.current.addLayer({
                                    id: `isochrone-a-${displayIdx}`,
                                    type: 'fill',
                                    source: `isochrone-a-${displayIdx}`,
                                    paint: {
                                        'fill-color': colorsA[idx],
                                        'fill-opacity': 0.3
                                    }
                                }, 'station-circles');
                            }
                        } catch (e) {
                            console.warn('Error creating isochrone A', idx, e);
                        }
                        
                        // STATION B ISOCHRONE
                        try {
                            let buffersB = [];
                            
                            const reachableB = Object.entries(timesFromB)
                                .filter(([_, time]) => time > 0 && time <= maxTimeMinutes)
                                .map(([stationId, duration]) => {
                                    const station = STATIONS.find(s => s.id === stationId);
                                    if (!station) return null;
                                    
                                    const leftoverMinutes = maxTimeMinutes - duration;
                                    const bufferKm = leftoverMinutes * 0.072;
                                    
                                    return turf.buffer(
                                        turf.point([station.lon, station.lat]),
                                        bufferKm > 0 ? bufferKm : 0.01,
                                        { units: 'kilometers' }
                                    );
                                })
                                .filter(b => b !== null);
                            
                            buffersB = [...reachableB];
                            
                            if (idx > 0 && isochronesB[idx - 1]) {
                                const prevBuffer = turf.buffer(
                                    isochronesB[idx - 1],
                                    0.720,
                                    { units: 'kilometers' }
                                );
                                buffersB.push(...prevBuffer.features);
                            }
                            
                            if (buffersB.length > 0) {
                                const fc = turf.featureCollection(buffersB);
                                const dissolved = turf.dissolve(fc);
                                
                                isochronesB[idx] = dissolved;
                                
                                const displayIdx = timeIntervals.length - 1 - idx;
                                map.current.addSource(`isochrone-b-${displayIdx}`, {
                                    type: 'geojson',
                                    data: dissolved
                                });

                                map.current.addLayer({
                                    id: `isochrone-b-${displayIdx}`,
                                    type: 'fill',
                                    source: `isochrone-b-${displayIdx}`,
                                    paint: {
                                        'fill-color': colorsB[idx],
                                        'fill-opacity': 0.3
                                    }
                                }, 'station-circles');
                            }
                        } catch (e) {
                            console.warn('Error creating isochrone B', idx, e);
                        }
                    }

                    setIsCalculating(false);
                } catch (error) {
                    console.error('Error calculating equidistance:', error);
                    setIsCalculating(false);
                }
            };

            const reset = () => {
                if (!map.current || !mapLoaded) return;
                
                addDebugLog('Reset button clicked', 'info');
                
                try {
                    // Remove isochrone layers first
                    for (let i = 0; i < 4; i++) {
                        if (map.current.getLayer(`isochrone-a-${i}`)) {
                            map.current.removeLayer(`isochrone-a-${i}`);
                        }
                        if (map.current.getSource(`isochrone-a-${i}`)) {
                            map.current.removeSource(`isochrone-a-${i}`);
                        }
                        if (map.current.getLayer(`isochrone-b-${i}`)) {
                            map.current.removeLayer(`isochrone-b-${i}`);
                        }
                        if (map.current.getSource(`isochrone-b-${i}`)) {
                            map.current.removeSource(`isochrone-b-${i}`);
                        }
                    }

                    // Reset ALL station styling to default
                    map.current.setPaintProperty('station-circles', 'circle-color', '#ffffff');
                    map.current.setPaintProperty('station-circles', 'circle-radius', 8);
                    map.current.setPaintProperty('station-circles', 'circle-stroke-width', 2);
                    map.current.setPaintProperty('station-circles', 'circle-stroke-color', '#007cbf');
                    map.current.setPaintProperty('station-circles', 'circle-opacity', 1); // Reset opacity!
                    
                    // Update refs immediately
                    stationARef.current = null;
                    stationBRef.current = null;
                    selectionModeRef.current = true;
                    
                    // Clear state - this triggers re-renders
                    setStationA(null);
                    setStationB(null);
                    setIsCalculating(false);
                    setSelectionMode(true);
                    
                    addDebugLog('Reset complete - ready for selections', 'success');
                } catch (error) {
                    addDebugLog(`Error during reset: ${error.message}`, 'error');
                    console.error('Error during reset:', error);
                }
            };

            useEffect(() => {
                if (stationA && stationB && selectionMode) {
                    calculateEquidistance();
                }
            }, [stationA, stationB]);

            return (
                <>
                    <div ref={mapContainer} id="map" />
                    
                    <div className="controls">
                        <h2>Subway Equidistance</h2>
                        
                        <div className="station-select">
                            <label>Station A (Yellow)</label>
                            {stationA ? (
                                <div className="station-badge station-a">{stationA.name}</div>
                            ) : (
                                <div className="station-badge">Click a station</div>
                            )}
                        </div>

                        <div className="station-select">
                            <label>Station B (Blue)</label>
                            {stationB ? (
                                <div className="station-badge station-b">{stationB.name}</div>
                            ) : stationA ? (
                                <div className="station-badge prompt">
                                    ðŸ‘† Click another station
                                </div>
                            ) : (
                                <div className="station-badge">Click a station</div>
                            )}
                        </div>

                        <button onClick={reset}>
                            Reset Selection
                        </button>

                        <div className="instructions">
                            {!stationA && "Step 1: Click any subway station to select Station A"}
                            {stationA && !stationB && "Step 2: Click a different station to select Station B"}
                            {stationA && stationB && "Yellow areas closer to Station A, blue areas closer to Station B. Green stations are equidistant."}
                        </div>
                    </div>

                    {(stationA && stationB && !isCalculating) && (
                        <div className="legend">
                            <h3>Travel Time & Distance</h3>
                            <div className="legend-item">
                                <div className="legend-color" style={{background: '#FFD700'}}></div>
                                <span>Closer to {stationA.name}</span>
                            </div>
                            <div className="legend-item">
                                <div className="legend-color" style={{background: '#00FF00'}}></div>
                                <span>Equidistant (Â±2 min)</span>
                            </div>
                            <div className="legend-item">
                                <div className="legend-color" style={{background: '#1E90FF'}}></div>
                                <span>Closer to {stationB.name}</span>
                            </div>
                            <div style={{marginTop: '10px', fontSize: '11px', color: '#888'}}>
                                Isochrones show 10, 20, 30, 40 min reach<br/>
                                (subway + walking at 1.2 m/s)
                            </div>
                        </div>
                    )}

                    {isCalculating && (
                        <div className="loading">
                            Calculating equidistance zones...
                        </div>
                    )}
                    
                    {!dataLoaded && (
                        <div className="loading">
                            Loading travel time data...
                        </div>
                    )}
                    
                    <div className="debug-window">
                        <h3>Debug Console</h3>
                        {debugLogs.map((log, idx) => (
                            <div key={idx} className={`debug-line debug-${log.type}`}>
                                [{log.timestamp}] {log.message}
                            </div>
                        ))}
                        {debugLogs.length === 0 && (
                            <div className="debug-line">Waiting for events...</div>
                        )}
                    </div>
                </>
            );
        };

        ReactDOM.render(<SubwayEquidistanceMap />, document.getElementById('root'));
    </script>
</body>
</html>
