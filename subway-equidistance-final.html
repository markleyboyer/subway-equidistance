<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NYC Subway Equidistance Map</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src='https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js'></script>
    <link href='https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css' rel='stylesheet' />
    <script src='https://unpkg.com/@turf/turf@6.5.0/turf.min.js'></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
        }
        
        /* MapLibre Popup Styling */
        .maplibregl-popup-content {
            background: rgba(0, 0, 0, 0.95) !important;
            border: 1px solid #333 !important;
            border-radius: 6px !important;
            box-shadow: 0 4px 20px rgba(0,0,0,0.7) !important;
            padding: 12px !important;
        }
        .maplibregl-popup-tip {
            border-top-color: rgba(0, 0, 0, 0.95) !important;
        }
        
        #map {
            width: 100vw;
            height: 100vh;
        }
        .controls {
            position: absolute;
            top: 15px;
            left: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
            z-index: 1;
            border: 1px solid #333;
        }
        .controls h2 {
            font-size: 16px;
            margin-bottom: 10px;
            color: #ffffff;
            text-align: center;
        }
        .station-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            gap: 10px;
        }
        .station-select {
            flex: 1;
        }
        .station-select label {
            display: block;
            font-size: 11px;
            color: #aaaaaa;
            margin-bottom: 3px;
            font-weight: 600;
        }
        .station-badge {
            display: block;
            padding: 6px 8px;
            background: #222;
            border-radius: 4px;
            font-size: 12px;
            color: #ccc;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .station-badge.selected {
            background: #007cbf;
            color: white;
        }
        .station-badge.station-a {
            background: #FFD700;
            color: #000;
            font-weight: bold;
        }
        .station-badge.station-b {
            background: #1E90FF;
            color: white;
            font-weight: bold;
        }
        .station-badge.prompt {
            background: #444;
            color: #FFD700;
            font-weight: bold;
        }
        .instructions {
            font-size: 11px;
            color: #aaaaaa;
            line-height: 1.4;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #333;
            text-align: center;
        }
        .button-row {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }
        button {
            flex: 1;
            padding: 8px 12px;
            background: #007cbf;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
        }
        button:hover {
            background: #006399;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .debug-toggle {
            background: #333;
            padding: 4px 8px;
            font-size: 10px;
        }
        .debug-toggle:hover {
            background: #444;
        }
        .debug-window {
            position: absolute;
            bottom: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.9);
            color: #00ff00;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            font-family: 'Courier New', monospace;
            font-size: 10px;
            max-width: 350px;
            z-index: 1;
            border: 1px solid #333;
        }
        .debug-window.collapsed {
            padding: 0;
        }
        .debug-window.expanded {
            padding: 15px;
            max-height: 250px;
        }
        .debug-header {
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.9);
            border-bottom: 1px solid #333;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 8px 8px 0 0;
        }
        .debug-header h3 {
            color: #00ff00;
            font-size: 11px;
            margin: 0;
        }
        .debug-content {
            max-height: 200px;
            overflow-y: auto;
        }
        .debug-line {
            margin-bottom: 3px;
            line-height: 1.3;
        }
        .debug-error {
            color: #ff4444;
        }
        .debug-success {
            color: #44ff44;
        }
        .debug-info {
            color: #4444ff;
        }
        .legend {
            position: absolute;
            bottom: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.9);
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
            z-index: 1;
            border: 1px solid #333;
            max-width: 200px;
        }
        .legend h3 {
            font-size: 12px;
            margin-bottom: 8px;
            color: #ffffff;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
            font-size: 10px;
            color: #cccccc;
        }
        .legend-color {
            width: 20px;
            height: 12px;
            margin-right: 8px;
            border-radius: 2px;
        }
        
        /* Mobile styles */
        @media (max-width: 768px) {
            .controls {
                top: 10px;
                left: 10px;
                right: 10px;
                padding: 12px;
            }
            .controls h2 {
                font-size: 14px;
                margin-bottom: 8px;
            }
            .station-row {
                margin-bottom: 8px;
                gap: 8px;
            }
            .station-badge {
                font-size: 11px;
                padding: 5px 6px;
            }
            .instructions {
                font-size: 10px;
                margin-top: 8px;
                padding-top: 8px;
            }
            .legend {
                bottom: 10px;
                left: 10px;
                padding: 8px;
                max-width: 160px;
            }
            .legend h3 {
                font-size: 10px;
                margin-bottom: 6px;
            }
            .legend-item {
                font-size: 9px;
                margin-bottom: 4px;
            }
            .legend-color {
                width: 16px;
                height: 10px;
                margin-right: 6px;
            }
            .debug-window {
                bottom: 10px;
                right: 10px;
                max-width: 250px;
            }
            .debug-header h3 {
                font-size: 10px;
            }
            .debug-line {
                font-size: 9px;
            }
        }
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 20px 30px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            border: 1px solid #333;
            z-index: 1000;
            font-size: 16px;
            color: #ffffff;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Will be loaded from travel_times.json
        let TRAVEL_DATA = null;
        let STATIONS = [];

        const SubwayEquidistanceMap = () => {
            const mapContainer = useRef(null);
            const map = useRef(null);
            const popup = useRef(null);
            const [mapLoaded, setMapLoaded] = useState(false);
            const [dataLoaded, setDataLoaded] = useState(false);
            const [stationA, setStationA] = useState(null);
            const [stationB, setStationB] = useState(null);
            const [isCalculating, setIsCalculating] = useState(false);
            const [selectionMode, setSelectionMode] = useState(true);
            const [debugLogs, setDebugLogs] = useState([]);
            const [debugExpanded, setDebugExpanded] = useState(false);
            
            // Debug logging function
            const addDebugLog = (message, type = 'info') => {
                const timestamp = new Date().toLocaleTimeString();
                setDebugLogs(prev => [...prev.slice(-20), { message, type, timestamp }]);
            };
            
            // Load travel times data
            useEffect(() => {
                addDebugLog('Loading travel times data...', 'info');
                // Add cache-busting parameter to force reload
                fetch('travel_times.json?v=' + Date.now())
                    .then(response => response.json())
                    .then(data => {
                        TRAVEL_DATA = data;
                        STATIONS = Object.values(data.stations);
                        addDebugLog(`Loaded ${STATIONS.length} stations`, 'success');
                        
                        // Debug: Check connectivity
                        const sampleStation = Object.keys(data.travel_times)[0];
                        const sampleTimes = data.travel_times[sampleStation];
                        const nullCount = Object.values(sampleTimes).filter(t => t === null).length;
                        const validCount = Object.values(sampleTimes).filter(t => t !== null).length;
                        console.log(`DEBUG: Sample station ${sampleStation} can reach ${validCount}/${validCount + nullCount} stations`);
                        
                        setDataLoaded(true);
                    })
                    .catch(error => {
                        console.error('Error loading travel times:', error);
                        alert('Error loading travel times data. Please make sure travel_times.json is in the same directory.');
                    });
            }, []);
            
            // Use refs to track current state in event handlers
            const stationARef = useRef(null);
            const stationBRef = useRef(null);
            const selectionModeRef = useRef(true);
            
            // Helper function to reconstruct path using Dijkstra from travel times
            const reconstructPath = (fromStationId, toStationId) => {
                if (fromStationId === toStationId) {
                    return [fromStationId];
                }
                
                // Build a graph from travel_times - find direct connections
                const graph = {};
                for (const [source, destinations] of Object.entries(TRAVEL_DATA.travel_times)) {
                    graph[source] = [];
                    for (const [dest, time] of Object.entries(destinations)) {
                        if (time !== null && time > 0 && time < 10) { // Direct connections typically < 10 min
                            graph[source].push({ id: dest, time });
                        }
                    }
                }
                
                // Dijkstra's algorithm to find shortest path
                const distances = {};
                const previous = {};
                const pq = [[0, fromStationId]]; // [distance, node]
                const visited = new Set();
                
                distances[fromStationId] = 0;
                
                while (pq.length > 0) {
                    pq.sort((a, b) => a[0] - b[0]);
                    const [currentDist, currentId] = pq.shift();
                    
                    if (visited.has(currentId)) continue;
                    visited.add(currentId);
                    
                    if (currentId === toStationId) break;
                    
                    const neighbors = graph[currentId] || [];
                    for (const neighbor of neighbors) {
                        const newDist = currentDist + neighbor.time;
                        if (!(neighbor.id in distances) || newDist < distances[neighbor.id]) {
                            distances[neighbor.id] = newDist;
                            previous[neighbor.id] = currentId;
                            pq.push([newDist, neighbor.id]);
                        }
                    }
                }
                
                // Reconstruct path
                const path = [];
                let current = toStationId;
                while (current) {
                    path.unshift(current);
                    current = previous[current];
                }
                
                return path.length > 0 && path[0] === fromStationId ? path : [];
            };
            
            useEffect(() => {
                stationARef.current = stationA;
            }, [stationA]);
            
            useEffect(() => {
                stationBRef.current = stationB;
            }, [stationB]);
            
            useEffect(() => {
                selectionModeRef.current = selectionMode;
            }, [selectionMode]);

            useEffect(() => {
                if (map.current || !dataLoaded) return;

                map.current = new maplibregl.Map({
                    container: mapContainer.current,
                    style: {
                        version: 8,
                        sources: {
                            'carto-dark': {
                                type: 'raster',
                                tiles: [
                                    'https://a.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png',
                                    'https://b.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png',
                                    'https://c.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png'
                                ],
                                tileSize: 256,
                                attribution: '&copy; OpenStreetMap contributors &copy; CARTO'
                            }
                        },
                        layers: [{
                            id: 'carto-dark-layer',
                            type: 'raster',
                            source: 'carto-dark',
                            minzoom: 0,
                            maxzoom: 22
                        }]
                    },
                    center: [-73.97, 40.76],
                    zoom: 11
                });

                map.current.on('load', () => {
                    setMapLoaded(true);
                    
                    // Create a popup for showing travel times on hover
                    popup.current = new maplibregl.Popup({
                        closeButton: false,
                        closeOnClick: false,
                        offset: 15
                    });
                    
                    // Add station markers source
                    map.current.addSource('stations', {
                        type: 'geojson',
                        data: {
                            type: 'FeatureCollection',
                            features: STATIONS.map(station => ({
                                type: 'Feature',
                                properties: {
                                    id: station.id,
                                    name: station.name,
                                    routeText: (station.routes && station.routes.length > 0) ? station.routes.map(r => r.name).join(' ') : ''
                                },
                                geometry: {
                                    type: 'Point',
                                    coordinates: [station.lon, station.lat]
                                }
                            }))
                        }
                    });

                    // Add station circles
                    map.current.addLayer({
                        id: 'station-circles',
                        type: 'circle',
                        source: 'stations',
                        paint: {
                            'circle-radius': 6,
                            'circle-color': '#ffffff',
                            'circle-stroke-width': 0,
                            'circle-stroke-color': '#007cbf'
                        }
                    });
                    // Station click handler
                    const handleStationClick = (e) => {
                        if (!selectionModeRef.current) {
                            addDebugLog('Click ignored - not in selection mode', 'error');
                            return;
                        }
                        
                        const stationId = e.features[0].properties.id;
                        const station = STATIONS.find(s => s.id === stationId);
                        
                        if (!stationARef.current) {
                            addDebugLog(`Selected Station A: ${station.name}`, 'success');
                            setStationA(station);
                        } else if (!stationBRef.current && station.id !== stationARef.current.id) {
                            addDebugLog(`Selected Station B: ${station.name}`, 'success');
                            setStationB(station);
                        } else {
                            addDebugLog('Station already selected or same as A', 'error');
                        }
                    };
                    
                    map.current.on('click', 'station-circles', handleStationClick);

                    // Hover handler to show station info and travel times
                    map.current.on('mouseenter', 'station-circles', (e) => {
                        map.current.getCanvas().style.cursor = 'pointer';
                        
                        const stationId = e.features[0].properties.id;
                        const station = STATIONS.find(s => s.id === stationId);
                        const coordinates = [station.lon, station.lat];
                        
                        // Create MTA-style route badges
                        let routeBadges = '';
                        if (station.routes && station.routes.length > 0) {
                            routeBadges = station.routes.map(route => {
                                const bgColor = `#${route.color}`;
                                const textColor = `#${route.text_color}`;
                                return `<span style="display: inline-block; background: ${bgColor}; color: ${textColor}; 
                                    width: 22px; height: 22px; border-radius: 50%; text-align: center; 
                                    line-height: 22px; font-weight: bold; font-size: 12px; margin: 0 2px; 
                                    font-family: Helvetica, Arial, sans-serif;">${route.name}</span>`;
                            }).join('');
                        }
                        
                        // If both stations are selected, show travel times
                        if (stationARef.current && stationBRef.current) {
                            const timesFromA = TRAVEL_DATA.travel_times[stationARef.current.id] || {};
                            const timesFromB = TRAVEL_DATA.travel_times[stationBRef.current.id] || {};
                            
                            const timeToA = timesFromA[stationId] !== undefined ? timesFromA[stationId] : 999;
                            const timeToB = timesFromB[stationId] !== undefined ? timesFromB[stationId] : 999;
                            
                            const timeADisplay = timeToA === 999 ? '<span style="font-size: 10px; opacity: 0.7;">Not connected</span>' : timeToA.toFixed(1) + ' min';
                            const timeBDisplay = timeToB === 999 ? '<span style="font-size: 10px; opacity: 0.7;">Not connected</span>' : timeToB.toFixed(1) + ' min';
                            
                            // Reconstruct paths
                            let pathFromA = [];
                            let pathFromB = [];
                            if (timeToA !== 999 && stationId !== stationARef.current.id) {
                                pathFromA = reconstructPath(stationARef.current.id, stationId);
                            }
                            if (timeToB !== 999 && stationId !== stationBRef.current.id) {
                                pathFromB = reconstructPath(stationBRef.current.id, stationId);
                            }
                            
                            // Format path display (show first, ..., last few stations)
                            const formatPath = (path) => {
                                if (path.length === 0) return '';
                                if (path.length <= 4) {
                                    return path.map(id => STATIONS.find(s => s.id === id)?.name || id).join(' → ');
                                }
                                const first = STATIONS.find(s => s.id === path[0])?.name;
                                const secondLast = STATIONS.find(s => s.id === path[path.length - 2])?.name;
                                const last = STATIONS.find(s => s.id === path[path.length - 1])?.name;
                                return `${first} → ... (${path.length - 2} stops) ... → ${secondLast} → ${last}`;
                            };
                            
                            let pathDisplayA = '';
                            let pathDisplayB = '';
                            if (pathFromA.length > 1) {
                                pathDisplayA = `<div style="font-size: 10px; color: #FFD700; margin-top: 2px; opacity: 0.8;">${formatPath(pathFromA)}</div>`;
                            }
                            if (pathFromB.length > 1) {
                                pathDisplayB = `<div style="font-size: 10px; color: #1E90FF; margin-top: 2px; opacity: 0.8;">${formatPath(pathFromB)}</div>`;
                            }
                            
                            let explanationText = '';
                            if (timeToA === 999 || timeToB === 999) {
                                explanationText = `
                                    <div style="margin-top: 5px; padding-top: 3px; border-top: 1px solid #444; font-size: 10px; color: #888; font-style: italic;">
                                        ${timeToA === 999 && timeToB === 999 ? 
                                            'This station is on a disconnected network (e.g., Staten Island Railway)' : 
                                            'This station is not reachable from one of the selected stations'}
                                    </div>
                                `;
                            }
                            
                            const html = `
                                <div style="font-family: Arial, sans-serif; font-size: 12px; min-width: 200px; max-width: 350px; color: #fff;">
                                    <div style="font-weight: bold; margin-bottom: 5px; border-bottom: 1px solid #555; padding-bottom: 3px; color: #fff;">
                                        ${station.name}
                                    </div>
                                    ${routeBadges ? `<div style="margin: 5px 0; line-height: 26px;">${routeBadges}</div>` : ''}
                                    <div style="color: #FFD700; font-weight: bold; margin: 3px 0;">
                                        ↓ ${stationARef.current.name}: ${timeADisplay}
                                    </div>
                                    ${pathDisplayA}
                                    <div style="color: #1E90FF; font-weight: bold; margin: 3px 0; margin-top: 8px;">
                                        ↓ ${stationBRef.current.name}: ${timeBDisplay}
                                    </div>
                                    ${pathDisplayB}
                                    ${timeToA !== 999 && timeToB !== 999 ? `
                                        <div style="margin-top: 5px; padding-top: 3px; border-top: 1px solid #444; font-size: 11px; color: #aaa;">
                                            Difference: ${Math.abs(timeToA - timeToB).toFixed(1)} min
                                        </div>
                                    ` : explanationText}
                                </div>
                            `;
                            
                            popup.current.setLngLat(coordinates).setHTML(html).addTo(map.current);
                        } else {
                            // Before stations are selected, just show station name and routes
                            const html = `
                                <div style="font-family: Arial, sans-serif; font-size: 12px; min-width: 150px; color: #fff;">
                                    <div style="font-weight: bold; margin-bottom: 5px; color: #fff;">
                                        ${station.name}
                                    </div>
                                    ${routeBadges ? `<div style="margin: 5px 0; line-height: 26px;">${routeBadges}</div>` : ''}
                                </div>
                            `;
                            
                            popup.current.setLngLat(coordinates).setHTML(html).addTo(map.current);
                        }
                    });

                    map.current.on('mouseleave', 'station-circles', () => {
                        map.current.getCanvas().style.cursor = '';
                        popup.current.remove();
                    });
                });
            }, [dataLoaded]);

            // Update map markers when stations are selected (but only for initial selection, not after calculation)
            useEffect(() => {
                if (!mapLoaded || !map.current || !selectionMode) return;

                const selectedIds = [stationA?.id, stationB?.id].filter(Boolean);

                if (selectedIds.length > 0) {
                    map.current.setPaintProperty('station-circles', 'circle-color', [
                        'case',
                        ['==', ['get', 'id'], stationA?.id || ''], '#FFD700',
                        ['==', ['get', 'id'], stationB?.id || ''], '#1E90FF',
                        '#ffffff'
                    ]);

                    map.current.setPaintProperty('station-circles', 'circle-radius', [
                        'case',
                        ['in', ['get', 'id'], ['literal', selectedIds]], 12,
                        6
                    ]);

                    map.current.setPaintProperty('station-circles', 'circle-stroke-width', 2);
                    map.current.setPaintProperty('station-circles', 'circle-stroke-color', '#007cbf');
                } else {
                    // Reset to defaults when no stations selected
                    map.current.setPaintProperty('station-circles', 'circle-color', '#ffffff');
                    map.current.setPaintProperty('station-circles', 'circle-radius', 6);
                    map.current.setPaintProperty('station-circles', 'circle-stroke-width', 0);
                    map.current.setPaintProperty('station-circles', 'circle-stroke-color', 'transparent');
                    map.current.setPaintProperty('station-circles', 'circle-opacity', 1);
                }
            }, [stationA, stationB, mapLoaded, selectionMode]);

            const calculateEquidistance = async () => {
                if (!stationA || !stationB) return;

                addDebugLog('Starting equidistance calculation...', 'info');
                setIsCalculating(true);
                setSelectionMode(false);

                try {
                    // Get travel times from pre-computed data  (in minutes)
                    const timesFromA = TRAVEL_DATA.travel_times[stationA.id] || {};
                    const timesFromB = TRAVEL_DATA.travel_times[stationB.id] || {};
                    
                    // Remove existing layers
                    for (let i = 0; i < 4; i++) {
                        if (map.current.getLayer(`isochrone-a-${i}`)) {
                            map.current.removeLayer(`isochrone-a-${i}`);
                        }
                        if (map.current.getSource(`isochrone-a-${i}`)) {
                            map.current.removeSource(`isochrone-a-${i}`);
                        }
                        if (map.current.getLayer(`isochrone-b-${i}`)) {
                            map.current.removeLayer(`isochrone-b-${i}`);
                        }
                        if (map.current.getSource(`isochrone-b-${i}`)) {
                            map.current.removeSource(`isochrone-b-${i}`);
                        }
                    }

                    // Color stations based on relative distance
                    const stationColorData = STATIONS.map(station => {
                        const timeToA = timesFromA[station.id] !== undefined ? timesFromA[station.id] : 999;
                        const timeToB = timesFromB[station.id] !== undefined ? timesFromB[station.id] : 999;
                        
                        let color;
                        let isEquidistant = false;
                        let shouldShow = true;
                        const maxDisplayTime = 40; // Only show stations within 40 minutes
                        
                        if (station.id === stationA.id) {
                            color = '#FFD700'; // Gold/Yellow
                        } else if (station.id === stationB.id) {
                            color = '#1E90FF'; // Dodger Blue
                        } else if (timeToA === 999 && timeToB === 999) {
                            // Completely unreachable - hide
                            shouldShow = false;
                            color = '#666666';
                        } else if (timeToA > maxDisplayTime && timeToB > maxDisplayTime) {
                            // Too far from both - hide
                            shouldShow = false;
                            color = '#666666';
                        } else if (timeToA === 999) {
                            // Only reachable from B
                            if (timeToB <= maxDisplayTime) {
                                color = '#1E90FF';
                            } else {
                                shouldShow = false;
                                color = '#666666';
                            }
                        } else if (timeToB === 999) {
                            // Only reachable from A
                            if (timeToA <= maxDisplayTime) {
                                color = '#FFD700';
                            } else {
                                shouldShow = false;
                                color = '#666666';
                            }
                        } else {
                            // Calculate which station is closer
                            const diff = timeToA - timeToB; // positive = closer to B, negative = closer to A
                            const maxDiff = 20; // minutes - used for gradient scaling
                            
                            if (Math.abs(diff) <= 3) {
                                // Equidistant - gradient green based on average distance to both stations
                                const avgTime = (timeToA + timeToB) / 2;
                                // Closest equidistant stations (avg 5-15 min) = bright green
                                // Farther equidistant stations (avg 35+ min) = dark green
                                const minAvg = 5; // minutes
                                const maxAvg = 35; // minutes
                                const greenRatio = Math.max(0, Math.min(1, (maxAvg - avgTime) / (maxAvg - minAvg)));
                                
                                // Bright green: rgb(0, 255, 0), Dark green: rgb(0, 100, 0)
                                const g = Math.floor(100 + (255 - 100) * greenRatio);
                                color = `rgb(0, ${g}, 0)`;
                                isEquidistant = true;
                            } else if (diff < -3) {
                                // Closer to A (yellow)
                                // Gradient from yellow (#FFD700) to green (#00FF00)
                                const ratio = Math.min(Math.abs(diff + 3) / maxDiff, 1);
                                // Yellow: rgb(255, 215, 0), Green: rgb(0, 255, 0)
                                const r = Math.floor(255 * (1 - ratio));
                                const g = Math.floor(215 + (255 - 215) * ratio);
                                const b = 0;
                                color = `rgb(${r}, ${g}, ${b})`;
                            } else {
                                // Closer to B (blue)
                                // Gradient from blue (#1E90FF) to green (#00FF00)
                                const ratio = Math.min((diff - 3) / maxDiff, 1);
                                // Blue: rgb(30, 144, 255), Green: rgb(0, 255, 0)
                                const r = Math.floor(30 * (1 - ratio));
                                const g = Math.floor(144 + (255 - 144) * ratio);
                                const b = Math.floor(255 * (1 - ratio));
                                color = `rgb(${r}, ${g}, ${b})`;
                            }
                        }
                        
                        return { id: station.id, color, isEquidistant, shouldShow };
                    });

                    // Get IDs for different categories
                    const equidistantIds = stationColorData.filter(s => s.isEquidistant).map(s => s.id);
                    const hiddenIds = stationColorData.filter(s => !s.shouldShow).map(s => s.id);

                    // Debug: log how many equidistant stations we found
                    addDebugLog(`Found ${equidistantIds.length} equidistant stations`, 'success');
                    const equidistantStations = stationColorData.filter(s => s.isEquidistant);
                    equidistantStations.slice(0, 5).forEach(s => {
                        const station = STATIONS.find(st => st.id === s.id);
                        const timeToA = timesFromA[s.id];
                        const timeToB = timesFromB[s.id];
                        const avgTime = (timeToA + timeToB) / 2;
                        addDebugLog(`  ${station.name}: ${timeToA.toFixed(1)}min from A, ${timeToB.toFixed(1)}min from B, avg: ${avgTime.toFixed(1)}min`, 'info');
                    });
                    if (equidistantStations.length > 5) {
                        addDebugLog(`  ... and ${equidistantStations.length - 5} more`, 'info');
                    }

                    // Hide stations that are too far away
                    map.current.setPaintProperty('station-circles', 'circle-opacity', [
                        'case',
                        ['in', ['get', 'id'], ['literal', hiddenIds]], 0,
                        1
                    ]);
                    
                    // Set station colors
                    map.current.setPaintProperty('station-circles', 'circle-color', [
                        'match',
                        ['get', 'id'],
                        ...stationColorData.flatMap(s => [s.id, s.color]),
                        '#ffffff'
                    ]);
                    
                    // Set station stroke color - WHITE for equidistant stations only
                    map.current.setPaintProperty('station-circles', 'circle-stroke-color', [
                        'case',
                        ['in', ['get', 'id'], ['literal', equidistantIds]], '#ffffff',
                        'rgba(0,0,0,0)' // Transparent for non-equidistant
                    ]);
                    
                    // Set station stroke width - 4px for equidistant (very visible), 0 for others
                    map.current.setPaintProperty('station-circles', 'circle-stroke-width', [
                        'case',
                        ['in', ['get', 'id'], ['literal', equidistantIds]], 4,
                        0
                    ]);
                    
                    map.current.setPaintProperty('station-circles', 'circle-radius', [
                        'case',
                        ['==', ['get', 'id'], stationA.id], 12,
                        ['==', ['get', 'id'], stationB.id], 12,
                        6
                    ]);

                    // Following the NYC Subway Isochrones algorithm
                    // Walking speed: 1.2 m/s = 72 m/min = 0.072 km/min
                    const timeIntervals = [10, 20, 30, 40]; // minutes
                    // Yellow gradient for station A
                    const colorsA = ['rgba(255, 215, 0, 0.6)', 'rgba(255, 215, 0, 0.4)', 'rgba(255, 215, 0, 0.25)', 'rgba(255, 215, 0, 0.15)'];
                    // Blue gradient for station B
                    const colorsB = ['rgba(30, 144, 255, 0.6)', 'rgba(30, 144, 255, 0.4)', 'rgba(30, 144, 255, 0.25)', 'rgba(30, 144, 255, 0.15)'];
                    
                    const isochronesA = [];
                    const isochronesB = [];

                    // Process each time interval
                    for (let idx = 0; idx < timeIntervals.length; idx++) {
                        const maxTimeMinutes = timeIntervals[idx];
                        
                        // STATION A ISOCHRONE
                        try {
                            let buffersA = [];
                            
                            // Get all stations reachable within this time interval
                            const reachableA = Object.entries(timesFromA)
                                .filter(([_, time]) => time > 0 && time <= maxTimeMinutes)
                                .map(([stationId, duration]) => {
                                    const station = STATIONS.find(s => s.id === stationId);
                                    if (!station) return null;
                                    
                                    // Calculate leftover walking time
                                    const leftoverMinutes = maxTimeMinutes - duration;
                                    const bufferKm = leftoverMinutes * 0.072; // 1.2 m/s = 0.072 km/min
                                    
                                    return turf.buffer(
                                        turf.point([station.lon, station.lat]),
                                        bufferKm > 0 ? bufferKm : 0.01,
                                        { units: 'kilometers' }
                                    );
                                })
                                .filter(b => b !== null);
                            
                            buffersA = [...reachableA];
                            
                            // Buffer the previous isochrone by a full 10-minute walk
                            if (idx > 0 && isochronesA[idx - 1]) {
                                const prevBuffer = turf.buffer(
                                    isochronesA[idx - 1],
                                    0.720, // 10 minutes * 0.072 km/min
                                    { units: 'kilometers' }
                                );
                                buffersA.push(...prevBuffer.features);
                            }
                            
                            if (buffersA.length > 0) {
                                // Create feature collection and dissolve
                                const fc = turf.featureCollection(buffersA);
                                const dissolved = turf.dissolve(fc);
                                
                                isochronesA[idx] = dissolved;
                                
                                // Add to map (reverse order so largest is on bottom)
                                const displayIdx = timeIntervals.length - 1 - idx;
                                map.current.addSource(`isochrone-a-${displayIdx}`, {
                                    type: 'geojson',
                                    data: dissolved
                                });

                                map.current.addLayer({
                                    id: `isochrone-a-${displayIdx}`,
                                    type: 'fill',
                                    source: `isochrone-a-${displayIdx}`,
                                    paint: {
                                        'fill-color': colorsA[idx],
                                        'fill-opacity': 0.3
                                    }
                                }, 'station-circles');
                            }
                        } catch (e) {
                            console.warn('Error creating isochrone A', idx, e);
                        }
                        
                        // STATION B ISOCHRONE
                        try {
                            let buffersB = [];
                            
                            const reachableB = Object.entries(timesFromB)
                                .filter(([_, time]) => time > 0 && time <= maxTimeMinutes)
                                .map(([stationId, duration]) => {
                                    const station = STATIONS.find(s => s.id === stationId);
                                    if (!station) return null;
                                    
                                    const leftoverMinutes = maxTimeMinutes - duration;
                                    const bufferKm = leftoverMinutes * 0.072;
                                    
                                    return turf.buffer(
                                        turf.point([station.lon, station.lat]),
                                        bufferKm > 0 ? bufferKm : 0.01,
                                        { units: 'kilometers' }
                                    );
                                })
                                .filter(b => b !== null);
                            
                            buffersB = [...reachableB];
                            
                            if (idx > 0 && isochronesB[idx - 1]) {
                                const prevBuffer = turf.buffer(
                                    isochronesB[idx - 1],
                                    0.720,
                                    { units: 'kilometers' }
                                );
                                buffersB.push(...prevBuffer.features);
                            }
                            
                            if (buffersB.length > 0) {
                                const fc = turf.featureCollection(buffersB);
                                const dissolved = turf.dissolve(fc);
                                
                                isochronesB[idx] = dissolved;
                                
                                const displayIdx = timeIntervals.length - 1 - idx;
                                map.current.addSource(`isochrone-b-${displayIdx}`, {
                                    type: 'geojson',
                                    data: dissolved
                                });

                                map.current.addLayer({
                                    id: `isochrone-b-${displayIdx}`,
                                    type: 'fill',
                                    source: `isochrone-b-${displayIdx}`,
                                    paint: {
                                        'fill-color': colorsB[idx],
                                        'fill-opacity': 0.3
                                    }
                                }, 'station-circles');
                            }
                        } catch (e) {
                            console.warn('Error creating isochrone B', idx, e);
                        }
                    }

                    setIsCalculating(false);
                } catch (error) {
                    console.error('Error calculating equidistance:', error);
                    setIsCalculating(false);
                }
            };

            const reset = () => {
                if (!map.current || !mapLoaded) return;
                
                addDebugLog('Reset button clicked', 'info');
                
                try {
                    // Remove isochrone layers first
                    for (let i = 0; i < 4; i++) {
                        if (map.current.getLayer(`isochrone-a-${i}`)) {
                            map.current.removeLayer(`isochrone-a-${i}`);
                        }
                        if (map.current.getSource(`isochrone-a-${i}`)) {
                            map.current.removeSource(`isochrone-a-${i}`);
                        }
                        if (map.current.getLayer(`isochrone-b-${i}`)) {
                            map.current.removeLayer(`isochrone-b-${i}`);
                        }
                        if (map.current.getSource(`isochrone-b-${i}`)) {
                            map.current.removeSource(`isochrone-b-${i}`);
                        }
                    }

                    // Completely remove and recreate the station layer to ensure clean reset
                    if (map.current.getLayer('station-labels')) {
                        map.current.removeLayer('station-labels');
                    }
                    if (map.current.getLayer('station-circles')) {
                        map.current.removeLayer('station-circles');
                    }
                    
                    // Add station circles layer
                    map.current.addLayer({
                        id: 'station-circles',
                        type: 'circle',
                        source: 'stations',
                        paint: {
                            'circle-color': '#ffffff',
                            'circle-radius': 6,
                            'circle-opacity': 1,
                            'circle-stroke-width': 0,  // No outer circle
                            'circle-stroke-color': 'transparent'
                        }
                    });

                    // Recreate station route labels layer
                    map.current.addLayer({
                        id: 'station-route-labels',
                        type: 'symbol',
                        source: 'stations',
                        layout: {
                            'text-field': ['get', 'routeText'],
                            'text-size': 9,
                            'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'],
                            'text-offset': [0, -1.2],
                            'text-anchor': 'bottom',
                            'text-allow-overlap': false,
                            'text-optional': true
                        },
                        paint: {
                            'text-color': '#FFD700',
                            'text-halo-color': '#000000',
                            'text-halo-width': 1.5
                        }
                    });
                    
                    // Update refs immediately BEFORE state
                    stationARef.current = null;
                    stationBRef.current = null;
                    selectionModeRef.current = true;
                    
                    // Clear state - this triggers re-renders
                    setStationA(null);
                    setStationB(null);
                    setIsCalculating(false);
                    setSelectionMode(true);
                    
                    addDebugLog('Reset complete - ready for selections', 'success');
                    addDebugLog('Click any station to begin', 'info');
                } catch (error) {
                    addDebugLog(`Error during reset: ${error.message}`, 'error');
                    console.error('Error during reset:', error);
                }
            };

            useEffect(() => {
                if (stationA && stationB && selectionMode) {
                    calculateEquidistance();
                }
            }, [stationA, stationB]);

            return (
                <>
                    <div ref={mapContainer} id="map" />
                    
                    <div className="controls">
                        <h2>Subway Equidistance</h2>
                        
                        <div className="station-row">
                            <div className="station-select">
                                <label>Station A (Yellow)</label>
                                {stationA ? (
                                    <div className="station-badge station-a">{stationA.name}</div>
                                ) : (
                                    <div className="station-badge">Click a station</div>
                                )}
                            </div>

                            <div className="station-select">
                                <label>Station B (Blue)</label>
                                {stationB ? (
                                    <div className="station-badge station-b">{stationB.name}</div>
                                ) : stationA ? (
                                    <div className="station-badge prompt">
                                        👆 Click another
                                    </div>
                                ) : (
                                    <div className="station-badge">Click a station</div>
                                )}
                            </div>
                        </div>

                        <div className="button-row">
                            <button onClick={reset}>
                                Reset Selection
                            </button>
                            <button 
                                className="debug-toggle"
                                onClick={() => setDebugExpanded(!debugExpanded)}
                            >
                                Debug {debugExpanded ? '▼' : '▲'}
                            </button>
                        </div>

                        <div className="instructions">
                            {!stationA && "Step 1: Click any subway station to select Station A"}
                            {stationA && !stationB && "Step 2: Click a different station to select Station B"}
                            {stationA && stationB && "Yellow areas closer to Station A, blue areas closer to Station B. Green stations are equidistant."}
                        </div>
                    </div>

                    {(stationA && stationB && !isCalculating) && (
                        <div className="legend">
                            <h3>Travel Time & Distance</h3>
                            <div className="legend-item">
                                <div className="legend-color" style={{background: '#FFD700'}}></div>
                                <span>Closer to {stationA.name}</span>
                            </div>
                            <div className="legend-item">
                                <div className="legend-color" style={{background: '#00FF00'}}></div>
                                <span>Equidistant (±3 min)</span>
                            </div>
                            <div className="legend-item">
                                <div className="legend-color" style={{background: '#1E90FF'}}></div>
                                <span>Closer to {stationB.name}</span>
                            </div>
                            <div style={{marginTop: '8px', fontSize: '9px', color: '#888'}}>
                                Isochrones show 10, 20, 30, 40 min reach<br/>
                                (subway + walking at 1.2 m/s)
                            </div>
                        </div>
                    )}

                    {isCalculating && (
                        <div className="loading">
                            Calculating equidistance zones...
                        </div>
                    )}
                    
                    {!dataLoaded && (
                        <div className="loading">
                            Loading travel time data...
                        </div>
                    )}
                    
                    <div className={`debug-window ${debugExpanded ? 'expanded' : 'collapsed'}`}>
                        <div className="debug-header" onClick={() => setDebugExpanded(!debugExpanded)}>
                            <h3>Debug Console</h3>
                            <span style={{fontSize: '10px', color: '#888'}}>
                                {debugExpanded ? '▼' : '▲'}
                            </span>
                        </div>
                        {debugExpanded && (
                            <div className="debug-content">
                                {debugLogs.map((log, idx) => (
                                    <div key={idx} className={`debug-line debug-${log.type}`}>
                                        [{log.timestamp}] {log.message}
                                    </div>
                                ))}
                                {debugLogs.length === 0 && (
                                    <div className="debug-line">Waiting for events...</div>
                                )}
                            </div>
                        )}
                    </div>
                </>
            );
        };

        ReactDOM.render(<SubwayEquidistanceMap />, document.getElementById('root'));
    </script>
</body>
</html>
